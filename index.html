<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Constellation â€” multi-connect</title>
  <style>
    html,body { height:100%; margin:0; background:#030318; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; cursor:crosshair; }
    /* small overlay for instructions (optional) */
    #hint {
      position: absolute;
      left: 12px;
      top: 12px;
      color: rgba(220,230,255,0.85);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      font-size: 12px;
      background: rgba(0,0,0,0.18);
      padding: 8px 10px;
      border-radius: 8px;
      backdrop-filter: blur(6px);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hint"></div>
  <canvas id="c"></canvas>
  <script>
  (function(){
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    addEventListener('resize', resize);
    resize();

    // stored points: each { x, y, r, vx, vy, createdAt, phase }
    const points = [];
    // stored connections: each { aIdx, bIdx, createdAt, drawDuration, baseAlpha, lineWidth, sway, phase }
    const connections = [];

    function rand(min,max){ return Math.random()*(max-min)+min; }

    // pointerdown: create a new point (visible) and create connections from it -> every existing point
    canvas.addEventListener('pointerdown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);

      const now = performance.now() / 1000;

      // new point visible immediately and pulses
      const p = {
        x, y,
        r: rand(2.4,4.2),
        vx: rand(-0.02, 0.02),
        vy: rand(-0.02, 0.02),
        createdAt: now,
        phase: Math.random() * Math.PI * 2
      };

      // connect this new point to all previous points
      const newIndex = points.length;
      for (let i = 0; i < points.length; i++) {
        const conn = {
          aIdx: i,          // existing point index
          bIdx: newIndex,   // new point index
          createdAt: now,
          drawDuration: 0.35 + Math.random() * 0.45,
          baseAlpha: rand(0.55, 0.95),
          lineWidth: rand(0.7, 1.6),
          sway: rand(6, 20),
          phase: Math.random() * Math.PI * 2
        };
        connections.push(conn);
      }

      // push new point last (so indices in connections are valid)
      points.push(p);
    });

    // optional: right-click to clear
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      // hold Shift to clear only last, else clear all
      if (e.shiftKey) {
        points.pop();
        // remove connections that reference removed index
        // rebuild connections safely
        const valid = [];
        for (const c of connections) {
          if (c.aIdx < points.length && c.bIdx < points.length) valid.push(c);
        }
        connections.length = 0;
        Array.prototype.push.apply(connections, valid);
      } else {
        points.length = 0;
        connections.length = 0;
      }
    });

    // simple background starfield (positions are derived from canvas size; re-create on resize)
    let bgStars = [];
    function makeBg(){
      bgStars = [];
      const n = Math.floor((innerWidth * innerHeight) / (1200 * 1200) * 120) + 80;
      for (let i=0;i<n;i++){
        bgStars.push({
          x: Math.random() * innerWidth,
          y: Math.random() * innerHeight,
          r: rand(0.2, 1.1),
          a: rand(0.03, 0.18)
        });
      }
    }
    makeBg();
    addEventListener('resize', makeBg);

    // draw loop
    function draw(timeMs){
      const time = timeMs / 1000;

      // background
      ctx.fillStyle = '#030318';
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // subtle background stars
      for (const s of bgStars){
        ctx.beginPath();
        ctx.globalAlpha = s.a;
        ctx.fillStyle = '#dfefff';
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // draw connections
      for (let k=0; k<connections.length; k++){
        const C = connections[k];
        // resolve points (if a point was removed skip)
        if (C.aIdx >= points.length || C.bIdx >= points.length) continue;
        const A = points[C.aIdx];
        const B = points[C.bIdx];

        // gentle drift
        A.x += A.vx;
        A.y += A.vy;
        B.x += B.vx;
        B.y += B.vy;

        const mx = (A.x + B.x)/2 + Math.sin(C.phase + time * 0.6) * C.sway;
        const my = (A.y + B.y)/2 + Math.cos(C.phase + time * 0.6) * C.sway;

        const progress = Math.min(1, Math.max(0, (time - C.createdAt) / C.drawDuration ));

        // path
        const path = new Path2D();
        path.moveTo(A.x, A.y);
        path.quadraticCurveTo(mx, my, B.x, B.y);

        // stroke with glow scaled by progress
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineWidth = C.lineWidth;
        ctx.strokeStyle = `rgba(180,220,255,${0.95 * C.baseAlpha * progress})`;
        ctx.shadowBlur = 16 + 28 * progress;
        ctx.shadowColor = `rgba(150,200,255,${0.8 * progress * C.baseAlpha})`;
        // emulate partial stroke via dash
        const totalDash = 2000;
        ctx.setLineDash([ totalDash * progress, totalDash ]);
        ctx.stroke(path);
        ctx.restore();
      }

      // draw points (endpoints) after lines so they sit on top
      for (let i=0;i<points.length;i++){
        const P = points[i];
        // pulse
        const pulse = 0.95 + 0.45 * Math.sin(P.phase + time * 2.2);
        const ageFactor = Math.min(1, (time - P.createdAt) / 0.4); // new stars show brighter briefly
        const endpointAlpha = 0.6 + 0.4 * ageFactor;

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        // inner core
        ctx.shadowBlur = 20 * endpointAlpha;
        ctx.shadowColor = `rgba(255,235,200,${endpointAlpha})`;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,245,220,${0.95 * endpointAlpha})`;
        ctx.arc(P.x, P.y, P.r * (1 + 0.2 * pulse), 0, Math.PI*2);
        ctx.fill();

        // halo
        ctx.globalAlpha = 0.5 * endpointAlpha;
        ctx.beginPath();
        ctx.arc(P.x, P.y, P.r * (4 + 2 * pulse), 0, Math.PI*2);
        ctx.fillStyle = `rgba(180,210,255,${0.45})`;
        ctx.fill();
        ctx.restore();
      }

      // subtle vignette
      const g = ctx.createRadialGradient(innerWidth/2, innerHeight/2, Math.min(innerWidth, innerHeight)*0.15, innerWidth/2, innerHeight/2, Math.max(innerWidth, innerHeight)*0.9);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.22)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,innerWidth,innerHeight);

      requestAnimationFrame(draw);
    }

    requestAnimationFrame(draw);

  })();
  </script>
</body>
</html>
